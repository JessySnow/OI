# BFS
> BFS 全称是 Breadth First Search，中文名是宽度优先搜索，也叫广度优先搜索

所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。

在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。

算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。

## 伪代码

```
bfs(s) {
  q = new queue()
  q.push(s), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}
```

## 性质
- 时间复杂度: O(n + m)
    - 访问一个节点的所有邻接点需要遍历其所有的出边 O(m)
    - 访问边
- 空间复杂度: O(n)
    - 该复杂度来自记录已访问的数组(visited)和队列

### BFS 序列

在 BFS 过程中访问到的节点编号的序列

### 一般图上 BFS

如果原图不连通，只能访问到从起点出发能够到达的点。

BFS 序列通常也不唯一。

类似的我们也可以定义 BFS 树：在 BFS 过程中，通过记录每个节点从哪个点访问而来，可以建立一个树结构，即为 BFS 树。

### 应用

1. 在无权图中求某一个点到其他点的最短路径
2. 在 O(n + m) 的时间内求出所有的连通块 *
3. 有向无权图中找最小环，从每一个节点开始，如果发现即将访问到一个已经访问过的节点，说明发现了环
4. 在边权为 0/1 的图上求最短路

### 双端队列 BFS
> 适用于图中的边权不是恒为 1 的情况，即存在 0，1 两种边权的情况，此时如果要求从某点出发的最短路，需要使用双端 BFS

[例题](../algorithm/DequeBFS.java)

```
while (队列不为空) {
  int u = 队首;
  弹出队首;
  for (枚举 u 的邻居) {
    更新数据
    if (...)
      添加到队首;
    else
      添加到队尾;
  }
}
```

### 优先队列 BFS
> 将 BFS 模版中的队列替换为一个优先队列

该算法用于求解一般化后的 0/1 图上求最短路问题，即在有权图上寻找最短路问题
